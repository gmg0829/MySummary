
## GIL
首先需要明确的一点是GIL并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念。CPython是大部分环境下默认的Python执行环境。

在 CPython 中，全局解释器锁（GIL）是一个互斥锁，它保护对 python 对象的访问过程，防止多个线程同时执行 python 字节码。这个锁是必要的，这主要是因为 CPython 的内存管理不是线程安全的。

![cpu](
  ./cpu.webp)

![io](
  ./io.webp)


现在，从这两张图表中可以注意到以下几点：

- 在这两种情况下，单个进程的执行时间都比单个线程长。显然，进程比线程有更多的开销。

- 对于受 CPU 限制的任务，多个进程的性能比多个线程要好。然而，当我们使用 8x 并行化时，这种差异就变得不那么明显了。由于我的笔记本电脑中的处理器是四核的，因此最多有四个进程可以有效地使用多核。所以当我使用更多的进程时，它的伸缩性就不好。但是，它仍然比线程性能好很多，因为线程根本不能利用多个核。

- 对于 IO 绑定的任务，瓶颈不是 CPU。因此，GIL 带来的通常限制在这里不适用，多处理也没有优势。不仅如此，线程的轻量级开销实际上使它们比多处理更快，并且线程始终优于多处理。