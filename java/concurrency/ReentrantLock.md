重入锁，是指一个线程获取锁之后再尝试获取锁时会自动获取锁。

Lock接口中主要定义了 获取锁、尝试获取锁、释放锁、条件锁等几个方法。
ReentrantLock中主要定义了三个内部类：Sync、NonfairSync、FairSync。

（1）抽象类Sync实现了AQS的部分方法；
（2）NonfairSync实现了Sync，主要用于非公平锁的获取；
（3）FairSync实现了Sync，主要用于公平锁的获取。

为什么ReentrantLock默认采用的是非公平模式？
答：因为非公平模式效率比较高。
为什么非公平模式效率比较高？
答：因为非公平模式会在一开始就尝试两次获取锁，如果当时正好state的值为0，它就会成功获取到锁，少了排队导致的阻塞/唤醒过程，并且减少了线程频繁的切换带来的性能损耗。
非公平模式有什么弊端？
答：非公平模式有可能会导致一开始排队的线程一直获取不到锁，导致线程饿死。

条件锁，是指在获取锁之后发现当前业务场景自己无法处理，而需要等待某个条件的出现才可以继续处理时使用的一种锁。

条件锁的实现都在AQS的ConditionObject类中，ConditionObject实现了Condition接口。

await()和signal()方法都必须在获取锁之后释放锁之前使用；
await()方法会新建一个节点放到条件队列中，接着完全释放锁，然后阻塞当前线程并等待条件的出现；
signal()方法会寻找条件队列中第一个可用节点移到AQS队列中；
在调用signal()方法的线程调用unlock()方法才真正唤醒阻塞在条件上的节点（此时节点已经在AQS队列中）；
